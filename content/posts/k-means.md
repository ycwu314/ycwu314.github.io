---
title: "K-means算法"
date: 2024-02-29T15:14:52+08:00
tags: ["AI"]
categories: ["AI"]
description: K-means算法是一种聚类算法，用于将数据集分成K个不同的组（簇），使得每个数据点属于与其最近的簇中。
---

使用gpt整理。


# K-means算法

K-means算法是一种聚类算法，用于将数据集分成K个不同的组（簇），使得每个数据点属于与其最近的簇中。


以下是K-means算法的伪代码流程：

```
1. 选择簇的个数 K
2. 从数据集中随机选择 K 个数据点作为初始簇中心
3. 重复直到收敛或达到最大迭代次数：
   a. 对每个数据点 i：
      i. 计算其与各个簇中心的距离（通常使用欧氏距离）
      ii. 将数据点分配到距离最近的簇
   b. 对每个簇 j：
      i. 计算该簇中所有数据点的均值，更新簇中心为均值
4. 返回最终的簇分配和簇中心
```


# K-means 算法优缺点

K-means算法是一种简单而广泛使用的聚类算法，但它也有一些优点和缺点。

### 优点：

1. **简单易懂：** K-means算法直观而易于理解，是最简单的聚类算法之一。
  
2. **计算效率高：** 对于大型数据集，K-means通常计算速度较快。

3. **可扩展性：** K-means在处理大规模数据集时具有较好的可扩展性。

4. **适用于球状簇：** 当簇的形状大致呈球状时，K-means表现较好。

### 缺点：

1. **对初始值敏感：** K-means对初始簇中心的选择敏感，不同的初始值可能导致不同的最终结果。

2. **对异常值敏感：** K-means对异常值较为敏感，异常值可能影响簇的形成。

3. **需要指定簇的个数K：** 在运行算法之前，需要事先指定簇的个数K，但在某些情况下，簇的个数可能不容易确定。

4. **对非凸形状簇效果差：** K-means假设簇是球状的，对于非凸形状的簇效果可能不佳。

5. **局部最优解：** 由于K-means使用贪心策略，有可能陷入局部最优解，而不是全局最优解。

6. **不适用于不均衡簇大小：** 当簇的大小差异较大时，K-means可能无法有效地区分簇。



# K-means算法的缺点和对应改进


| 缺点                  | 改进方法  | 描述                                                |
|-----------------------|------------|-----------------------------------------------------|
| k值的确定             | ISODATA    | 当属于某个簇的样本数过少时把这个簇去除，当属于某个簇的样本数过多、分散程度较大时把这个簇分为两个子簇             |
| 对奇异点敏感         | k-median   | 中位数代替平均值作为簇中心                           |
| 只能找到球状群       | GMM        | 以高斯分布考虑簇内数据点的分布                       |
| 分群结果不稳定         | k-means++  | 初始的聚类中心之间的相互距离要尽可能的远               |

来源：
- [K-means总结](http://www.bithub00.com/2019/09/23/kmeans%E6%80%BB%E7%BB%93/)

# K-means ++ 算法

K-means++是对K-means初始簇中心的选择进行改进的一种算法。它通过修改簇中心的初始化过程，使得初始中心点更有可能分散在整个数据集中，从而提高算法的性能。

以下是K-means++算法的伪代码：

```python
1. 从输入数据点中随机选择一个点作为第一个簇中心
2. 重复以下步骤直到选择 K 个簇中心：
   a. 对于每个数据点 x，计算其与当前已选择簇中心的最近距离（d(x)^2）
   b. 随机选择下一个簇中心，选择的概率与其与已选择簇中心的距离成正比，即概率正比于 d(x)^2
3. 使用所选择的初始簇中心运行标准的K-means算法
```

K-means++通过更智能地选择初始簇中心，减少了收敛到次优解的可能性，提高了算法的稳定性和效果。在实践中，K-means++通常比随机选择初始中心的标准K-means算法更快速和有效。


# k means 的算法复杂度


K-means算法的时间复杂度主要取决于两个方面：迭代次数和每次迭代的计算量。以下是K-means算法的一般时间复杂度：

1. **迭代次数：** K-means算法通常需要进行多次迭代，直到收敛。迭代次数的上限通常是用户预先指定的参数，例如最大迭代次数。在实际应用中，K-means通常在较少的迭代次数内收敛，但具体次数取决于数据的特性和初始簇中心的选择。

2. **每次迭代的计算量：** 在每次迭代中，需要计算每个数据点与当前簇中心的距离，并更新簇中心。这涉及到数据集的遍历和距离计算。对于N个数据点和K个簇中心，每次迭代的时间复杂度约为O(N * K * d)，其中d是数据点的特征维度。注意，这是一个粗略的估算，实际计算量还取决于具体的优化实现和算法细节。

综合考虑迭代次数和每次迭代的计算量，K-means算法的总体时间复杂度通常在O(I * N * K * d)，其中I是迭代次数，N是数据点数量，K是簇的数量，d是数据点的特征维度。

需要注意的是，K-means的时间复杂度是线性的，而且通常在实践中具有较好的可扩展性，使其适用于处理大规模数据集。

