<!-- build time:Thu Dec 24 2020 16:28:34 GMT+0800 (China Standard Time) --><!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="keywords" content="java,微服务,分布式系统,架构设计"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.6/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css"><link rel="stylesheet" href="/css/main.css?v=7.1.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2"><link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"7.1.2",sidebar:{position:"left",display:"hide",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!1,fancybox:!0,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="僵尸进程消耗pid空间。linux中pid 1进程负责回收僵尸进程。docker中ENTRYPOINT、CMD入口的进程为pid 1进程。docker如果以shell作为init进程，那么不能正确处理信号传播和僵尸进程回收。docker stop/kill向容器发送信号。tini是一个轻量级的init进程，docker 1.13以后集成了tini，通过`docker --init`启动，并且修改p"><meta name="keywords" content="docker init,docker tini,docker pid 1"><meta property="og:type" content="article"><meta property="og:title" content="docker &amp; 僵尸进程 &amp; tini"><meta property="og:url" content="https://ycwu314.cloud/p/docker-init-and-zombie-reaping/index.html"><meta property="og:site_name" content="ycwu314"><meta property="og:description" content="僵尸进程消耗pid空间。linux中pid 1进程负责回收僵尸进程。docker中ENTRYPOINT、CMD入口的进程为pid 1进程。docker如果以shell作为init进程，那么不能正确处理信号传播和僵尸进程回收。docker stop/kill向容器发送信号。tini是一个轻量级的init进程，docker 1.13以后集成了tini，通过`docker --init`启动，并且修改p"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://ycwu314.cloud/p/docker-init-and-zombie-reaping/v2_reaping.png"><meta property="og:image" content="https://ycwu314.cloud/p/docker-init-and-zombie-reaping/v2_adoption.png"><meta property="og:image" content="https://ycwu314.cloud/p/docker-init-and-zombie-reaping/v2_bash_signal.png"><meta property="og:updated_time" content="2020-12-24T08:27:14.356Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="docker &amp; 僵尸进程 &amp; tini"><meta name="twitter:description" content="僵尸进程消耗pid空间。linux中pid 1进程负责回收僵尸进程。docker中ENTRYPOINT、CMD入口的进程为pid 1进程。docker如果以shell作为init进程，那么不能正确处理信号传播和僵尸进程回收。docker stop/kill向容器发送信号。tini是一个轻量级的init进程，docker 1.13以后集成了tini，通过`docker --init`启动，并且修改p"><meta name="twitter:image" content="https://ycwu314.cloud/p/docker-init-and-zombie-reaping/v2_reaping.png"><link rel="canonical" href="https://ycwu314.cloud/p/docker-init-and-zombie-reaping/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>docker & 僵尸进程 & tini | ycwu314</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">ycwu314</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">潮的工地</h1></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-collection"><a href="/collection" rel="section"><i class="menu-item-icon fa fa-fw fa-file-code-o"></i><br>专题</a></li><li class="menu-item menu-item-tags"><a href="/t/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://ycwu314.cloud/p/docker-init-and-zombie-reaping/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ycwu314"><meta itemprop="description" content="java, 微服务, 分布式系统, 架构设计"><meta itemprop="image" content="/images/avatar.webp"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ycwu314"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">docker & 僵尸进程 & tini</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-05-12 10:55:41" itemprop="dateCreated datePublished" datetime="2020-05-12T10:55:41+08:00">2020-05-12</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-12-24 16:27:14" itemprop="dateModified" datetime="2020-12-24T16:27:14+08:00">2020-12-24</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/c/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a></span></span><br><span title="post.wordcount">共&nbsp;2.3k&nbsp;字 <span class="post-meta-divider">|</span> </span><span title="post.min2read">阅读时间&nbsp;9&nbsp;分钟</span><div class="post-description">僵尸进程消耗pid空间。linux中pid 1进程负责回收僵尸进程。docker中ENTRYPOINT、CMD入口的进程为pid 1进程。docker如果以shell作为init进程，那么不能正确处理信号传播和僵尸进程回收。docker stop/kill向容器发送信号。tini是一个轻量级的init进程，docker 1.13以后集成了tini，通过`docker --init`启动，并且修改pid 1进程。</div></div></header><div class="post-body" itemprop="articleBody"><p style="text-align:center;font-size:14px">本文作者ycwu314，未经允许请勿转载 <a href="https://ycwu314.cloud/p/docker-init-and-zombie-reaping/">docker & 僵尸进程 & tini</a> : https://ycwu314.cloud/p/docker-init-and-zombie-reaping/<br>&#x6E29;&#x99A8;&#x63D0;&#x793A;&#xFF1A;&#x5982;&#x679C;&#x4E0D;&#x662F;&#x5728;&#x8FD9;&#x4E9B;&#x5730;&#x65B9;&#x770B;&#x5230;&#x8FD9;&#x7BC7;&#x6587;&#x7AE0;&#xFF0C;&#x90A3;&#x4E48;&#x4F60;&#x53EF;&#x80FD;&#x662F;&#x722C;&#x866B;&#x6587;&#x7AE0;&#x7684;&#x53D7;&#x5BB3;&#x8005;&#xFF1A;<br>https://ycwu314.top/ (原https://ycwu314.github.io/)<br>&#x672A;&#x7ECF;&#x6388;&#x6743;&#x7684;&#x8F6C;&#x8F7D;&#xFF0C;&#x4E0D;&#x4EC5;&#x6253;&#x51FB;&#x539F;&#x521B;&#x79EF;&#x6781;&#x6027;&#xFF0C;&#x8FD8;&#x83B7;&#x53D6;&#x4E0D;&#x5230;&#x6700;&#x65B0;&#x7684;&#x6587;&#x7AE0;&#x66F4;&#x65B0;&#x4FE1;&#x606F;&#x3002;</p><h1 id="僵尸进程、PID-1 进程"><a href="# 僵尸进程、PID-1 进程" class="headerlink" title="僵尸进程、PID 1 进程"></a>僵尸进程、PID 1 进程</h1><p>推荐阅读这篇文章，快速了解僵尸进程、pid 1 进程：</p><ul><li><a href="https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/" rel="external nofollow noopener noreferrer" target="_blank">Docker and the PID 1 zombie reaping problem</a></li></ul><p>在 unix 系列系统，父进程应该等待子进程结束（waitpid 系统调用）：</p><blockquote><p>Unix is designed in such a way that parent processes must explicitly “wait” for child process termination, in order to collect its exit status.</p></blockquote><a id="more"></a><p>当子进程结束，会向父进程发送 SIGCHLD 信号，通知父进程回收</p><img src="https://s2.ax1x.com/2019/09/06/nMx2i4.png" data-original="/p/docker-init-and-zombie-reaping/v2_reaping.png" title="reaping"><p>会有一种异常情况，父进程在子进程结束之前被杀死，那么这个子进程会被 pid 1 进程管理：</p><img src="https://s2.ax1x.com/2019/09/06/nMx2i4.png" data-original="/p/docker-init-and-zombie-reaping/v2_adoption.png" title="adoption"><p>在 docker 中，如果使用 bash 作为 pid 1 进程，那么向容器发送 SIGTERM 信号，bash 退出了，但是没有向子进程传递信号、等待子进程关闭，导致形成僵尸进程</p><img src="https://s2.ax1x.com/2019/09/06/nMx2i4.png" data-original="/p/docker-init-and-zombie-reaping/v2_bash_signal.png" title="bash_signal"><p>PID 1 有一个独特的职责，那就是收割“僵尸进程”。init 进程周期执行 wait 系统调用 reap 其所收养的所有僵尸进程。</p><p>那么 what is 僵尸进程：</p><ul><li>已经退出</li><li>父进程也退出</li><li>没有被其父进程 wait（wait 是指 syscall 父进程用于检索其子进程的退出代码）</li></ul><blockquote><p>from a Unix operating system point of view – zombie processes have a very specific definition. They are processes that have terminated but have not (yet) been waited for by their parent processes.</p></blockquote><p>init 进程的职责：向子进程发送信号，同时等待子进程结束：</p><blockquote><p>Sending signals to child processes is not enough: the init process must also wait for child processes to terminate, before terminating itself. If the init process terminates prematurely then all children are terminated uncleanly by the kernel.</p></blockquote><p>僵尸进程的危害：消耗 PID 空间。<br>僵尸进程被 reap 后，其进程号与在进程表中的表项都可以被系统重用。但如果父进程没有调用 wait，僵尸进程将保留进程表中的表项，导致资源泄漏。</p><p>如何处理僵尸进程</p><blockquote><p>父进程捕获 SIGCHLD 信号，并调用 wait 或 waitpid。</p></blockquote><p>什么是 SIGCHLD？来自百度：</p><blockquote><p>在一个进程终止或者停止时，将 SIGCHLD 信号发送给其父进程。按系统默认将忽略此信号。如果父进程希望被告知其子系统的这种状态，则应捕捉此信号。信号的捕捉函数中通常调用 wait 函数以取得进程 ID 和其终止状态。</p></blockquote><p>如何避免僵尸进程？（来自文章：<a href="https://www.cnblogs.com/wuchanming/p/4020463.html" rel="external nofollow noopener noreferrer" target="_blank">linux 下的僵尸进程处理 SIGCHLD 信号 </a>）</p><ul><li>通过 signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN); 表示父进程忽略 SIGCHLD 信号，该信号是子进程退出的时候向父进程发送的。</li><li>父进程调用 wait/waitpid 等函数等待子进程结束，如果尚无子进程退出 wait 会导致父进程阻塞。waitpid 可以通过传递 WNOHANG 使父进程不阻塞立即返回。</li><li>如果父进程很忙可以用 signal 注册信号处理函数，在信号处理函数调用 wait/waitpid 等待子进程退出。</li><li>通过两次调用 fork。父进程首先调用 fork 创建一个子进程然后 waitpid 等待子进程退出，子进程再 fork 一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由 init 进程接管，孙进程结束后，init 会等待回收。</li></ul><p>SIG_IGN 又是什么？</p><blockquote><p><code>signal.h</code>中的宏定义 <code>SIG_DFL</code> 及<code>SIG_IGN</code><br>SIG_DFL, SIG_IGN 分别表示无返回值的函数指针，指针值分别是 0 和 1，这两个指针值逻辑上讲是实际程序中不可能出现的函数地址值。<br>SIG_DFL：默认信号处理程序<br>SIG_IGN：忽略信号的处理程序</p></blockquote><p>ps. defunct: 死了的；不存在的</p><h1 id="docker 容器和信号处理"><a href="#docker 容器和信号处理" class="headerlink" title="docker 容器和信号处理"></a>docker 容器和信号处理</h1><p>Docker 的 stop 和 kill 命令都是用来向容器发送信号的。注意，只有容器中的 1 号进程能够收到信号。</p><blockquote><p>stop 命令会首先发送 SIGTERM 信号，并等待应用优雅的结束。默认是等待 10s，可以通过<code>-t &lt;seconds&gt;</code> 设置等待时间；如果发现应用没有结束 (用户可以指定等待的时间)，就再发送一个 SIGKILL 信号强行结束程序。</p><p>kill 命令默认发送的是 SIGKILL 信号，当然你可以通过 -s 选项指定任何信号。</p></blockquote><p>如果 PID 1 不处理信号传递，那么由 PID 1 启动的子进程将不能接收 docker 发送的信号（比如 bash 作为 ENTRYPOINT 入口）。</p><h1 id="案例一：- 非 PID-1 的 ENTRYPOINT 进程不能正确处理 SIGTERM"><a href="# 案例一：- 非 PID-1 的 ENTRYPOINT 进程不能正确处理 SIGTERM" class="headerlink" title="案例一： 非 PID 1 的 ENTRYPOINT 进程不能正确处理 SIGTERM"></a>案例一： 非 PID 1 的 ENTRYPOINT 进程不能正确处理 SIGTERM</h1><p>Dockerfile</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="DOCKERFILE"><figure class="iseeu highlight /dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.11</span>.<span class="number">6</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> ycwu</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> t.sh .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod u+x t.sh</span></span><br><span class="line"><span class="comment"># 使用 </span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"./t.sh"</span>]</span></span><br></pre></td></tr></table></figure></div><p>其中 <code>t.sh</code> 文件</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> `seq 1 1000`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line">  sleep 1</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div><p>然后构建镜像。</p><p>第一个窗口执行</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@host143 ycwu]<span class="comment"># docker run -it --name  test  ycwu/ycwu-alpine:v1 </span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure></div><p>第二个窗口执行</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@host143 ~]<span class="comment"># docker exec -it test top</span></span><br><span class="line">Mem: 16025852K used, 224024K free, 54120K shrd, 40K buff, 4391664K cached</span><br><span class="line">CPU:   7% usr  10% sys   0% nic  82% idle   0% io   0% irq   0% sirq</span><br><span class="line">Load average: 0.02 0.04 0.05 3/1192 66</span><br><span class="line">  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND</span><br><span class="line">    1     0 root     S     1584   0%   0   0% &#123;t.sh&#125; /bin/sh ./t.sh</span><br><span class="line">   61     0 root     R     1568   0%   1   0% top</span><br><span class="line">   66     1 root     S     1560   0%   2   0% sleep 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># shell 脚本以 /bin/sh 解析</span></span><br><span class="line"></span><br><span class="line">[root@host143 ~]<span class="comment"># docker stop test</span></span><br><span class="line"><span class="comment"># stop 命令会首先发送 SIGTERM 信号，并等待应用优雅的结束。如果发现应用没有结束(用户可以指定等待的时间)，就再发送一个 SIGKILL 信号强行结束程序。</span></span><br><span class="line"><span class="comment"># 在此期间窗口一继续输出数字。</span></span><br><span class="line"><span class="comment"># sleep 本身支持响应 SIGTERM 信号，但是外层的 sh 并没有传递信号。</span></span><br></pre></td></tr></table></figure></div><h1 id="tini"><a href="#tini" class="headerlink" title="tini"></a>tini</h1><p>tini 是一个极简的 init 程序。使用 tini 的好处：</p><ul><li>避免产生僵尸进程</li><li>为 docker 容器提供默认的信号处理器，能够处理 SIGTERM</li></ul><p>tini 原理：</p><blockquote><p>After spawning your process, Tini will wait for signals and forward those to the child process, and periodically reap zombie processes that may be created within your container.</p><p>When the “first” child process exits (/your/program in the examples above), Tini exits as well, with the exit code of the child process (so you can check your container’s exit code to know whether the child exited successfully).</p></blockquote><p>tini 使用 tips：</p><ol><li><p>Tini 在退出时会重复使用子进程的退出代码。可以使用 <code>-e</code> 把任意子进程的 exit code 重新映射为 0。</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="DOCKERFILE"><figure class="iseeu highlight /dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/tini"</span>, <span class="string">"-v"</span>, <span class="string">"-e"</span>, <span class="string">"143"</span>, <span class="string">"--"</span>, <span class="string">"your_app"</span>]</span></span><br></pre></td></tr></table></figure></div></li><li><p>Tini 可以使用 <code>-v</code>、<code>-vv</code>、<code>-vvv</code> 输出更多的 debug 信息。</p></li><li><p>Tini 可以结合 <code>docker-entrypoint.sh</code> 使用。</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="DOCKERFILE"><figure class="iseeu highlight /dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/tini"</span>, <span class="string">"--"</span>, <span class="string">"/docker-entrypoint.sh"</span>]</span></span><br></pre></td></tr></table></figure></div></li><li><p>Subreaping 问题。<br>默认情况下 tini 应该作为 PID 1 进程，这样能够回收僵尸进程。如果 tini 不能作为 PID 1 进程，则可以使用 <code>-s</code> 参数：</p></li></ol><ul><li><code>tini -s --</code></li></ul><h1 id="tini 和 docker-init 关系"><a href="#tini 和 docker-init 关系" class="headerlink" title="tini 和 docker --init 关系"></a>tini 和 <code>docker --init</code> 关系</h1><blockquote><p>NOTE: If you are using Docker 1.13 or greater, Tini is included in Docker itself. This includes all versions of Docker CE. To enable Tini, just pass the –init flag to docker run.<br><code>--init</code>: Run an init inside the container that forwards signals and reaps processes</p></blockquote><p>docker 1.13 以后内置了 tini，通过<code>--init</code> 启动。<br>用 docker 时，如果不加 <code>--init</code> 参数，容器中的 1 号进程就是所给的 ENTRYPOINT，而加上 <code>--init</code> 之后，1 号进程就会是 tini。<br>tini 进程能够将终止信号转发给其子进程, 同时能 reap 子进程, 不会出现因孤儿进程导致的线程句柄无法回收情形。</p><h1 id="案例二：-docker-init 和信号处理"><a href="# 案例二：-docker-init 和信号处理" class="headerlink" title="案例二： docker init 和信号处理"></a>案例二： docker init 和信号处理</h1><p>这里使用 docker CE 19.03.5。<br>还是上面的镜像，但是启动时候加上 <code>--init</code>:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@host143 ~]<span class="comment"># docker run -it --init  ycwu/ycwu-alpine:v1</span></span><br><span class="line"></span><br><span class="line">[root@host143 ~]<span class="comment"># docker exec -it 9da ps aux</span></span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 root      0:00 /sbin/docker-init -- ./t.sh</span><br><span class="line">    6 root      0:00 &#123;t.sh&#125; /bin/sh ./t.sh</span><br><span class="line">   66 root      0:00 sleep 1</span><br><span class="line">   67 root      0:00 ps aux</span><br></pre></td></tr></table></figure></div><p>加上 <code>--init</code> 之后，PID 1 进程变成了 <code>/sbin/docker-init</code>，并且由它来执行 ENTRYPOINT 指定的脚本。</p><p>第二个窗口执行：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@host143 ~]<span class="comment"># docker stop  9da </span></span><br><span class="line">9da</span><br></pre></td></tr></table></figure></div><p>第一个窗口立即退出了。因此 SIGTERM 信号能够正确传播到 <code>./t.sh</code>。</p><h1 id="使用 tini 向前兼容"><a href="# 使用 tini 向前兼容" class="headerlink" title="使用 tini 向前兼容"></a> 使用 tini 向前兼容</h1><p>为 docker 1.13 以前版本增加 tini 支持，比如在 alpine 基础镜像：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="DOCKERFILE"><figure class="iseeu highlight /dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache tini bash</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/tini"</span>, <span class="string">"--"</span>, <span class="string">"/docker-entrypoint.sh"</span>]</span></span><br></pre></td></tr></table></figure></div><h1 id="案例三：-java 容器化"><a href="# 案例三：-java 容器化" class="headerlink" title="案例三： java 容器化"></a>案例三： java 容器化</h1><p>在容器中通过自定义脚本启动 java 应用，</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="DOCKERFILE"><figure class="iseeu highlight /dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"./run.sh"</span>]</span></span><br></pre></td></tr></table></figure></div><p>init 进程是 sh 或者 bash，处理了 SIGTERM，但是没有传播到里面启动的 java 进程；这就导致了 java 不能正常接收 docker 发出的 SIGTERM，不能实现优雅关闭。</p><p>如果直接使用 java 作为 init 进程，则可以接收 docker 发送的信号：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="DOCKERFILE"><figure class="iseeu highlight /dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"java"</span>, <span class="string">"-jar"</span>, ...]</span></span><br></pre></td></tr></table></figure></div><p>但是 openjdk 对于 java 作为 init 进程有点 bug：<a href="https://github.com/docker-library/openjdk/issues/76" rel="external nofollow noopener noreferrer" target="_blank">jmap not happy on alpine #76</a>。</p><p>现在可以简单地使用 <code>docker --init</code> 或者 tini，避免 java 作为 PID 1 进程；解决了僵尸进程、信号处理、openjdk 工具 bug 问题。</p><h1 id="其他 init 进程方案"><a href="# 其他 init 进程方案" class="headerlink" title="其他 init 进程方案"></a>其他 init 进程方案</h1><p>例如 sysvinit、upstart、systemd、supervisord。<br>但是相比 tini，都很重型。<br>TODO：后续了解这些方案。</p><h1 id="小结"><a href="# 小结" class="headerlink" title="小结"></a>小结</h1><ul><li>docker 1.13 以后，集成了 tini。<code>docker --init</code> 把 PID 1 进程修改为 <code>/sbin/docker-init --</code></li><li>docker 1.13 以前，可以手动在镜像安装 tini</li></ul><h1 id="参考"><a href="# 参考" class="headerlink" title="参考"></a> 参考</h1><ul><li><a href="https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/" rel="external nofollow noopener noreferrer" target="_blank">Docker and the PID 1 zombie reaping problem</a></li><li><a href="https://www.cnblogs.com/wuchanming/p/4020463.html" rel="external nofollow noopener noreferrer" target="_blank">linux 下的僵尸进程处理 SIGCHLD 信号</a></li><li><a href="https://zhuanlan.zhihu.com/p/59796137" rel="external nofollow noopener noreferrer" target="_blank">在 entrypoint.sh 中使用 Tini 的优势是什么？</a></li><li><a href="https://github.com/krallin/tini" rel="external nofollow noopener noreferrer" target="_blank">krallin / tini</a></li><li><a href="https://www.cnblogs.com/sparkdev/p/7598590.html" rel="external nofollow noopener noreferrer" target="_blank">在 docker 容器中捕获信号</a></li><li><a href="https://www.jianshu.com/p/200ad2a547bf" rel="external nofollow noopener noreferrer" target="_blank">docker reap 僵尸进程问题</a></li></ul><h1>题外话</h1><p style="text-align:center;font-size:14px">&#x672C;&#x6587;&#x4F5C;&#x8005;ycwu314，&#x672A;&#x7ECF;&#x5141;&#x8BB8;&#x8BF7;&#x52FF;&#x8F6C;&#x8F7D; <a href="https://ycwu314.cloud/p/docker-init-and-zombie-reaping/">docker & 僵尸进程 & tini</a> : https://ycwu314.cloud/p/docker-init-and-zombie-reaping/</p><p style="text-align:center;font-size:16px;font-weight:700">你的支持将鼓励我继续更多原创分享！</p><img src="https://s2.ax1x.com/2019/09/06/nMx2i4.png" data-original="https://s2.ax1x.com/2019/08/12/ezfUk8.jpg" style="width:50%;margin:0 auto"></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/p/linux-hostname-dns-config-files/" rel="bookmark">linux 主机解析相关配置文件</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/p/docker-macvlan-network/" rel="bookmark">docker macvlan network 实验</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/p/docker-overlay-network/" rel="bookmark">docker overlay network 实验</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/p/iptables-docker/" rel="bookmark">iptables docker</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/p/docker-nsenter/" rel="bookmark">使用 nsenter 访问 docker 容器</a></div></li></ul><div><div id="reward-container"><div>你的支持将鼓励我继续更多原创分享！</div><button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="https://s2.ax1x.com/2019/09/06/nMx2i4.png" data-original="https://s2.ax1x.com/2019/08/12/ezfUk8.jpg" alt="ycwu314 微信支付"><p>微信支付</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>ycwu314</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://ycwu314.cloud/p/docker-init-and-zombie-reaping/" title="docker & 僵尸进程 & tini">https://ycwu314.cloud/p/docker-init-and-zombie-reaping/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均为原创文章，未经允许请勿转载！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/t/docker/" rel="tag"># docker</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/p/docker-dockerfile-in-practise/" rel="next" title="dockerfile 使用经验"><i class="fa fa-chevron-left"></i> dockerfile 使用经验</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/p/docker-find-container-process-on-host-machine/" rel="prev" title="docker 容器进程和宿主机进程映射">docker 容器进程和宿主机进程映射 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.webp" alt="ycwu314"><p class="site-author-name" itemprop="name">ycwu314</p><div class="site-description motion-element" itemprop="description">java, 微服务, 分布式系统, 架构设计</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/arch"><span class="site-state-item-count">268</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/c/"><span class="site-state-item-count">57</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/t/"><span class="site-state-item-count">99</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/ycwu314" title="GitHub &rarr; https://github.com/ycwu314" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:ycwu314@foxmail.com" title="E-Mail &rarr; mailto:ycwu314@foxmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#僵尸进程、PID-1 进程"><span class="nav-number">1.</span> <span class="nav-text">僵尸进程、PID 1 进程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker 容器和信号处理"><span class="nav-number">2.</span> <span class="nav-text">docker 容器和信号处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#案例一：- 非 PID-1 的 ENTRYPOINT 进程不能正确处理 SIGTERM"><span class="nav-number">3.</span> <span class="nav-text">案例一： 非 PID 1 的 ENTRYPOINT 进程不能正确处理 SIGTERM</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tini"><span class="nav-number">4.</span> <span class="nav-text">tini</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tini 和 docker-init 关系"><span class="nav-number">5.</span> <span class="nav-text">tini 和 docker --init 关系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#案例二：-docker-init 和信号处理"><span class="nav-number">6.</span> <span class="nav-text">案例二： docker init 和信号处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用 tini 向前兼容"><span class="nav-number">7.</span> <span class="nav-text">使用 tini 向前兼容</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#案例三：-java 容器化"><span class="nav-number">8.</span> <span class="nav-text">案例三： java 容器化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其他 init 进程方案"><span class="nav-number">9.</span> <span class="nav-text">其他 init 进程方案</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number">10.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">11.</span> <span class="nav-text">参考</span></a></li></ol></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2020</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">ycwu314</span> <span class="post-meta-divider">|</span> <span class="post-count">共&nbsp;275.1k&nbsp;字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.6/jquery.fancybox.min.js"></script><script src="/js/utils.js?v=7.1.2"></script><script src="/js/motion.js?v=7.1.2"></script><script src="/js/schemes/muse.js?v=7.1.2"></script><script src="/js/scrollspy.js?v=7.1.2"></script><script src="/js/post-details.js?v=7.1.2"></script><script src="/js/next-boot.js?v=7.1.2"></script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script>!function(t){function n(){for(var n=0;n<e.length;n++)i=e[n],0<=(o=i.getBoundingClientRect()).top&&0<=o.left&&o.top<=(t.innerHeight||document.documentElement.clientHeight)&&function(){var t,i,o,c,r=e[n];t=r,i=function(){e=e.filter(function(t){return r!==t})},o=new Image,c=t.getAttribute("data-original"),o.onload=function(){t.src=c,i&&i()},o.src=c}();var i,o}var e=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));n(),t.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(n,t)})}(this)</script></body></html><!-- rebuild by neat -->