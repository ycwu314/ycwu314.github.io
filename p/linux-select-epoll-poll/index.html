<!-- build time:Thu Dec 24 2020 16:28:49 GMT+0800 (China Standard Time) --><!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="keywords" content="java,微服务,分布式系统,架构设计"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.6/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css"><link rel="stylesheet" href="/css/main.css?v=7.1.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2"><link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"7.1.2",sidebar:{position:"left",display:"hide",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!1,fancybox:!0,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="select使用数组实现，最大长度受限于FD_SETSIZE。poll和epoll使用数组实现，没有限制。select和poll都要把数据从内核空间复制到用户空间，epoll使用mmap映射，不需要复制。select和poll是水平触发，epoll支持边缘触发。select和poll每次都要检查所有打开的FD，epoll可以只检查活跃的FD。"><meta name="keywords" content="select vs epoll,IO多路复用,水平触发 边缘触发,FD_SETSIZE"><meta property="og:type" content="article"><meta property="og:title" content="linux select epoll poll 简介"><meta property="og:url" content="https://ycwu314.cloud/p/linux-select-epoll-poll/index.html"><meta property="og:site_name" content="ycwu314"><meta property="og:description" content="select使用数组实现，最大长度受限于FD_SETSIZE。poll和epoll使用数组实现，没有限制。select和poll都要把数据从内核空间复制到用户空间，epoll使用mmap映射，不需要复制。select和poll是水平触发，epoll支持边缘触发。select和poll每次都要检查所有打开的FD，epoll可以只检查活跃的FD。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://ycwu314.cloud/p/linux-select-epoll-poll/v2_linux_select.png"><meta property="og:updated_time" content="2020-12-24T08:27:14.332Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="linux select epoll poll 简介"><meta name="twitter:description" content="select使用数组实现，最大长度受限于FD_SETSIZE。poll和epoll使用数组实现，没有限制。select和poll都要把数据从内核空间复制到用户空间，epoll使用mmap映射，不需要复制。select和poll是水平触发，epoll支持边缘触发。select和poll每次都要检查所有打开的FD，epoll可以只检查活跃的FD。"><meta name="twitter:image" content="https://ycwu314.cloud/p/linux-select-epoll-poll/v2_linux_select.png"><link rel="canonical" href="https://ycwu314.cloud/p/linux-select-epoll-poll/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>linux select epoll poll 简介 | ycwu314</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">ycwu314</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">潮的工地</h1></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-collection"><a href="/collection" rel="section"><i class="menu-item-icon fa fa-fw fa-file-code-o"></i><br>专题</a></li><li class="menu-item menu-item-tags"><a href="/t/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://ycwu314.cloud/p/linux-select-epoll-poll/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ycwu314"><meta itemprop="description" content="java, 微服务, 分布式系统, 架构设计"><meta itemprop="image" content="/images/avatar.webp"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ycwu314"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">linux select epoll poll 简介</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-08-14 14:57:32" itemprop="dateCreated datePublished" datetime="2019-08-14T14:57:32+08:00">2019-08-14</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-12-24 16:27:14" itemprop="dateModified" datetime="2020-12-24T16:27:14+08:00">2020-12-24</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/c/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span></span><br><span title="post.wordcount">共&nbsp;2.4k&nbsp;字 <span class="post-meta-divider">|</span> </span><span title="post.min2read">阅读时间&nbsp;9&nbsp;分钟</span><div class="post-description">select使用数组实现，最大长度受限于FD_SETSIZE。poll和epoll使用数组实现，没有限制。select和poll都要把数据从内核空间复制到用户空间，epoll使用mmap映射，不需要复制。select和poll是水平触发，epoll支持边缘触发。select和poll每次都要检查所有打开的FD，epoll可以只检查活跃的FD。</div></div></header><div class="post-body" itemprop="articleBody"><p style="text-align:center;font-size:14px">本文作者ycwu314，未经允许请勿转载 <a href="https://ycwu314.cloud/p/linux-select-epoll-poll/">linux select epoll poll 简介</a> : https://ycwu314.cloud/p/linux-select-epoll-poll/<br>&#x6E29;&#x99A8;&#x63D0;&#x793A;&#xFF1A;&#x5982;&#x679C;&#x4E0D;&#x662F;&#x5728;&#x8FD9;&#x4E9B;&#x5730;&#x65B9;&#x770B;&#x5230;&#x8FD9;&#x7BC7;&#x6587;&#x7AE0;&#xFF0C;&#x90A3;&#x4E48;&#x4F60;&#x53EF;&#x80FD;&#x662F;&#x722C;&#x866B;&#x6587;&#x7AE0;&#x7684;&#x53D7;&#x5BB3;&#x8005;&#xFF1A;<br>https://ycwu314.top/ (原https://ycwu314.github.io/)<br>&#x672A;&#x7ECF;&#x6388;&#x6743;&#x7684;&#x8F6C;&#x8F7D;&#xFF0C;&#x4E0D;&#x4EC5;&#x6253;&#x51FB;&#x539F;&#x521B;&#x79EF;&#x6781;&#x6027;&#xFF0C;&#x8FD8;&#x83B7;&#x53D6;&#x4E0D;&#x5230;&#x6700;&#x65B0;&#x7684;&#x6587;&#x7AE0;&#x66F4;&#x65B0;&#x4FE1;&#x606F;&#x3002;</p><p>在这篇文章简单介绍了 linux IO 模型。</p><ul><li><a href="/p/io-model/" title="io 模型">io 模型 </a>linux 的 select、poll、epoll 函数是 IO 多路复用的基础。这次聊聊这几个函数。<br>内容来自以前的有道笔记，当时没有记录参考文章。<a id="more"></a><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1></li></ul><img src="https://s2.ax1x.com/2019/09/06/nMx2i4.png" data-original="/p/linux-select-epoll-poll/v2_linux_select.png" title="linux select"><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">         &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USE_XOPEN</span></span><br><span class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">else</span></span></span><br><span class="line">         __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">         &#125; fd_set ;</span><br></pre></td></tr></table></figure></div><p>(一个 fd 占用一个 bit)<br>由数组 fds_bits[<strong>FD_SETSIZE / __NFDBITS]的定义可以看出，它将数组 fds_bits 的长度从通常的 </strong>FD_SETSIZE 缩短到了（<strong>FD_SETSIZE / __NFDBITS），数组的元素的每个位表示一个描述符，那么一个元素就可以表示</strong>NFDBITS 个描述符，整个数组就可以表示（__FD_SETSIZE / __NFDBITS）* __NFDBITS = __FD_SETSIZE 个描述符了。<br>__FDS_BITS 的定义是为了便于直接引用该结构中的 fds_bits，而不用关心内部具体的定义。</p><p><code>int select(int maxfd,fd_set *rdset,fd_set *wrset,fd_set *exset,struct timeval *timeout);</code></p><p>参数 maxfd 是需要监视的最大的文件描述符值 +1；rdset,wrset,exset 分别对应于需要检测的可读文件描述符的集合，可写文件描述符的集合及异常文件描述符的集合。struct timeval 结构用于描述一段时间长度，如果在这个时间内，需要监视的描述符没有事件发生则函数返回，返回值为 0。</p><p>基于 <strong>数组 </strong>的实现。</p><p>优点：</p><ol><li>posix 定义的，可移植性好。</li><li>适用于少量连接。</li></ol><p>缺点：</p><ol><li><p>单个进程可以监控的 fd 数量限制 FD_SETSIZE。</p><blockquote><p>cat /proc/sys/fs/file-max 察看。32 位机默认是 1024 个。64 位机默认是 2048.</p></blockquote></li><li><p>对 socket 扫描是线性的，要扫描 fd_size 个，不管 socket 是否就绪。epoll，kqueue 改进了此处，使用回调函数，不盲目扫描 socket 浪费 cpu 时间</p></li><li><p>维护一个重型的 fd 数据结构，并且从内核空间拷贝到用户空间。</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************/</span></span><br><span class="line"><span class="comment">/* Copy the master fd_set over to the working fd_set.     */</span></span><br><span class="line"><span class="comment">/**********************************************************/</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;working_set, &amp;master_set, <span class="keyword">sizeof</span>(master_set));</span><br></pre></td></tr></table></figure></div></li></ol><!-- more --><h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> fd;               <span class="comment">/* 文件描述符 */</span></span><br><span class="line">  <span class="keyword">short</span> events;         <span class="comment">/* 等待的事件 */</span></span><br><span class="line">  <span class="keyword">short</span> revents;       <span class="comment">/* 实际发生了的事件 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *ufds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></div><p>poll 函数使用 pollfd 类型的结构来监控一组文件句柄，ufds 是要监控的文件句柄集合，nfds 是监控的文件句柄数量，timeout 是等待的毫秒数，这段时间内无论 I/O 是否准备好，poll 都会返回。timeout 为负数表示无线等待，timeout 为 0 表示调用后立即返回。<br>执行结果：为 0 表示超时前没有任何事件发生；-1 表示失败；成功则返回结构体中 revents 不为 0 的文件描述符个数</p><p>优点：</p><ol><li>使用链表结构。不受 fd 最大数量限制</li></ol><p>缺点：</p><ol><li>检查 socket 还是要遍历整个数据。</li><li>水平触发：<strong>如果这次报告 fd 已经可以操作但是没有处理，那么下次该 fd 还会被报告 </strong>。</li></ol><h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>通常 1g 内存可以打开 10w 个 epoll 连接。</p><p><code>int epoll_create(int size);</code><br>创建一个 epoll 的句柄，size 用来告诉内核需要监听的数目一共有多大。当创建好 epoll 句柄后，它就是会占用一个 fd 值，在 linux 下如果查看 /proc/ 进程 id/fd/，是能够看到这个 fd 的，所以在使用完 epoll 后，必须调用 close() 关闭，否则可能导致 fd 被耗尽。</p><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code><br>epoll 的事件注册函数，第一个参数是 epoll_create() 的返回值，第二个参数表示动作，使用如下三个宏来表示：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EPOLL_CTL_ADD    <span class="comment">// 注册新的 fd 到 epfd 中；</span></span><br><span class="line">EPOLL_CTL_MOD    <span class="comment">// 修改已经注册的 fd 的监听事件；</span></span><br><span class="line">EPOLL_CTL_DEL    <span class="comment">// 从 epfd 中删除一个 fd；</span></span><br></pre></td></tr></table></figure></div><p>第三个参数是需要监听的 fd，第四个参数是告诉内核需要监听什么事，struct epoll_event 结构如下：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span>        *ptr;</span><br><span class="line">  <span class="keyword">int</span>          fd;</span><br><span class="line">  <span class="keyword">__uint32_t</span>   u32;</span><br><span class="line">  <span class="keyword">__uint64_t</span>   u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line"><span class="keyword">__uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line"><span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>events 可以是以下几个宏的集合：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EPOLLIN     <span class="comment">// 表示对应的文件描述符可以读（包括对端 SOCKET 正常关闭）；</span></span><br><span class="line">EPOLLOUT    <span class="comment">// 表示对应的文件描述符可以写；</span></span><br><span class="line">EPOLLPRI    <span class="comment">// 表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span></span><br><span class="line">EPOLLERR    <span class="comment">// 表示对应的文件描述符发生错误；</span></span><br><span class="line">EPOLLHUP    <span class="comment">// 表示对应的文件描述符被挂断；</span></span><br><span class="line">EPOLLET     <span class="comment">// 将 EPOLL 设为边缘触发 (Edge Triggered) 模式，这是相对于水平触发 (Level Triggered) 来说的。</span></span><br><span class="line">EPOLLONESHOT<span class="comment">// 只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 socket 的话，需要再次把这个 socket 加入到 EPOLL 队列里。</span></span><br></pre></td></tr></table></figure></div><p>当对方关闭连接 (FIN), EPOLLERR，都可以认为是一种 EPOLLIN 事件，在 read 的时候分别有 0，-1 两个返回值。</p><p><code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</code><br>参数 events 用来从内核得到事件的集合，maxevents 告之内核这个 events 有多大，这个 maxevents 的值不能大于创建 epoll_create() 时的 size，参数 timeout 是超时时间（毫秒，0 会立即返回，-1 将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回 0 表示已超时。</p><p>epoll 支持两种 fd 扫描方式，水平触发和边缘触发</p><ul><li>LT(level triggered，水平触发模式) 是缺省的工作方式，并且同时支持 block 和 non-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。</li><li>ET(edge-triggered，边缘触发模式)是高速工作方式，<strong>只支持 no-block socket</strong>。在这种模式下，当描述符从未就绪变为就绪时，内核通过 epoll 告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，等到下次有新的数据进来的时候才会再次出发就绪事件。</li></ul><p>ET 模式减少了 epoll 事件被重复触发的问题。但是可能错过事件：如果一直不对这个 fd 作 IO 操作 (从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。<br>（redis 使用 LT，nginx 使用 ET）</p><p>优点：</p><ol><li>没有描述符数量限制。</li><li>支持水平触发和边缘触发</li><li>使用事件回调处理就绪的 fd，而非遍历 fd。<br>epoll_ctl 首先注册了文件描述符。一旦该 fd 就绪，就由内核激活该 fd，当进程调用 epoll_wait()时便得到通知。</li></ol><h1 id="select，poll，epoll 对比"><a href="#select，poll，epoll 对比" class="headerlink" title="select，poll，epoll 对比"></a>select，poll，epoll 对比</h1><table><thead><tr><th></th><th>select</th><th>poll</th><th>epoll</th></tr></thead><tbody><tr><td>单个进程打开连接数限制</td><td>受 FD_SETSIZE 限制</td><td>无限制</td><td>无限制</td></tr><tr><td>事件检查方式</td><td>遍历 fd 数组</td><td>同 select</td><td>由内核调用事件的 callback</td></tr><tr><td>打开大量 FD 后的性能表现</td><td>因为线性遍历检查 fd 数组，所以性能线性下降</td><td>同 select</td><td>只有活跃的 socket 才会触发 epoll。因此性能只受活跃 socket 数量影响</td></tr><tr><td>消息传播</td><td>从内核空间复制到用户空间</td><td>同 select</td><td>内核与用户空间 mmap 同一块内存，无需复制</td></tr><tr><td>事件触发模式</td><td>水平触发</td><td>水平触发</td><td>水平触发 or 边缘触发</td></tr></tbody></table><h1 id="pselect-ppoll"><a href="#pselect-ppoll" class="headerlink" title="pselect, ppoll"></a>pselect, ppoll</h1><p>解决的问题</p><ul><li>在检查 signal 后和调用 select()之前，丢失了 signal。</li></ul><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> struct timespec *timeout, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">             <span class="keyword">long</span>    tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">             <span class="keyword">long</span>    tv_nsec;        <span class="comment">/* nanoseconds */</span></span><br><span class="line">         &#125;;</span><br></pre></td></tr></table></figure></div><p>它和 select() 函数基本相同，区别在于两个不同的参数，一个是 struct timespec *timeout，另一个是 sigset_t *sigmask。<br>和 select() 不同，每次超时后，pselect() 并不会去修改这个时间参数，也就是说，没有必要再次对这个时间参数进行初始化。</p><p>对于最后一个参数 sigmask 表示信号屏蔽掩码。<strong>该参数允许程序先禁止递交某些信号，再测试由这些当前被禁止的信号处理函数设置的全局变量，然后调用 pselect，告诉它重新设置信号掩码。</strong></p><p>使用 pselect() 函数一个最大的原因正是它可以防止信号的干扰。比如说，如果你只是使用 select() 函数，在超时时间内很可能还会受到时钟信号 (SIGALARM) 的打断，从而影响 select() 的正常使用。</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(need_to_quit)      <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(select(...) == <span class="number">-1</span>) <span class="comment">// 2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> need_to_quit = <span class="number">0</span>; <span class="comment">// handler interrupt</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigquit_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    need_to_quit = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>假设 need_to_quit 接收 SIGINT 信号。如果在 1）和 2）之间发生 SIGINT，那么会丢失 SIGINT 信号的处理，结果可能一直在 select 调用中阻塞等待。</p><p>posix 的解决方法：</p><blockquote><p>step 1 : you block all signals and save the current sigmask<br>step 2 : check the event condition and do what is required<br>step 3 : call pselect() and pass it a signal mask to enable all the signals that would provide you the events. when pselect() returns, it will restore the sigmask it had when it was entered(ie, here all the signals masked).<br>step 4 : you restore the old signal mask</p></blockquote><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pselect(..)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// enable the signals to be received</span></span><br><span class="line">    sigprocmask(.., &amp;new_mask, &amp;old_mask);  <span class="comment">// 1</span></span><br><span class="line">    select();                               <span class="comment">// 2</span></span><br><span class="line">    sigprocmask(.., &amp;old_mask, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>pselect 类似上面的代码。但是用户模式下自己定义一个这样的函数，会在 1）和 2）之间产生竞争条件。posix 提供的 pselect 会进入内核模式，不会产生竞争。</p><p>最终的代码流程如下：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sigset_t</span> new_set, old_set;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">sigfillmask(&amp;new_set);</span><br><span class="line">sigprocmask(.., null, &amp;old_set);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sigprocmask(.., &amp;new_set, null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(need_to_quit)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    ret = pselect(.., &amp;old_set) ;</span><br><span class="line">    sigprocmask(.., &amp;old_set, null);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    sigprocmask(.., &amp;old_set, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="kqueue"><a href="#kqueue" class="headerlink" title="kqueue"></a>kqueue</h1><p>BSD 系统上独有，类似 epoll。但是更复杂。</p><h1>题外话</h1><p style="text-align:center;font-size:14px">&#x672C;&#x6587;&#x4F5C;&#x8005;ycwu314，&#x672A;&#x7ECF;&#x5141;&#x8BB8;&#x8BF7;&#x52FF;&#x8F6C;&#x8F7D; <a href="https://ycwu314.cloud/p/linux-select-epoll-poll/">linux select epoll poll 简介</a> : https://ycwu314.cloud/p/linux-select-epoll-poll/</p><p style="text-align:center;font-size:16px;font-weight:700">你的支持将鼓励我继续更多原创分享！</p><img src="https://s2.ax1x.com/2019/09/06/nMx2i4.png" data-original="https://s2.ax1x.com/2019/08/12/ezfUk8.jpg" style="width:50%;margin:0 auto"></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/p/io-model/" rel="bookmark">io 模型</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/p/reactor-pattern/" rel="bookmark">reactor 模式</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/p/linux-selinux-intro/" rel="bookmark">selinux 简介</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/p/linux-mem-p4-zoneinfo/" rel="bookmark">linux 内存系列 4：zoneinfo 和水位</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/p/linux-mem-p3-anon-page/" rel="bookmark">linux 内存系列 3：匿名页和内存映射</a></div></li></ul><div><div id="reward-container"><div>你的支持将鼓励我继续更多原创分享！</div><button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="https://s2.ax1x.com/2019/09/06/nMx2i4.png" data-original="https://s2.ax1x.com/2019/08/12/ezfUk8.jpg" alt="ycwu314 微信支付"><p>微信支付</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>ycwu314</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://ycwu314.cloud/p/linux-select-epoll-poll/" title="linux select epoll poll 简介">https://ycwu314.cloud/p/linux-select-epoll-poll/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均为原创文章，未经允许请勿转载！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/t/linux/" rel="tag"># linux</a> <a href="/t/高并发/" rel="tag"># 高并发</a> <a href="/t/IO/" rel="tag"># IO</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/p/reactor-pattern/" rel="next" title="reactor 模式"><i class="fa fa-chevron-left"></i> reactor 模式</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/p/java-wait-vs-sleep/" rel="prev" title="java wait() 和 sleep() 的区别">java wait() 和 sleep() 的区别 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.webp" alt="ycwu314"><p class="site-author-name" itemprop="name">ycwu314</p><div class="site-description motion-element" itemprop="description">java, 微服务, 分布式系统, 架构设计</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/arch"><span class="site-state-item-count">268</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/c/"><span class="site-state-item-count">57</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/t/"><span class="site-state-item-count">99</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/ycwu314" title="GitHub &rarr; https://github.com/ycwu314" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:ycwu314@foxmail.com" title="E-Mail &rarr; mailto:ycwu314@foxmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#select"><span class="nav-number">1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#poll"><span class="nav-number">2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#epoll"><span class="nav-number">3.</span> <span class="nav-text">epoll</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#select，poll，epoll 对比"><span class="nav-number">4.</span> <span class="nav-text">select，poll，epoll 对比</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pselect-ppoll"><span class="nav-number">5.</span> <span class="nav-text">pselect, ppoll</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#kqueue"><span class="nav-number">6.</span> <span class="nav-text">kqueue</span></a></li></ol></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2020</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">ycwu314</span> <span class="post-meta-divider">|</span> <span class="post-count">共&nbsp;275.1k&nbsp;字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.6/jquery.fancybox.min.js"></script><script src="/js/utils.js?v=7.1.2"></script><script src="/js/motion.js?v=7.1.2"></script><script src="/js/schemes/muse.js?v=7.1.2"></script><script src="/js/scrollspy.js?v=7.1.2"></script><script src="/js/post-details.js?v=7.1.2"></script><script src="/js/next-boot.js?v=7.1.2"></script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script>!function(t){function n(){for(var n=0;n<e.length;n++)i=e[n],0<=(o=i.getBoundingClientRect()).top&&0<=o.left&&o.top<=(t.innerHeight||document.documentElement.clientHeight)&&function(){var t,i,o,c,r=e[n];t=r,i=function(){e=e.filter(function(t){return r!==t})},o=new Image,c=t.getAttribute("data-original"),o.onload=function(){t.src=c,i&&i()},o.src=c}();var i,o}var e=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));n(),t.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(n,t)})}(this)</script></body></html><!-- rebuild by neat -->